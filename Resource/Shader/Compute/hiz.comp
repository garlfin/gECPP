#ifndef PIPELINE_DEPTH_COPY_FORMAT
    #define PIPELINE_DEPTH_COPY_FORMAT r32f
#endif

#define HIZ_MODE_COPY 0
#define HIZ_MODE_DOWNSAMPLE 1

// IO
layout(location = 0) uniform vec4 Settings; // Mode, MIP, Near, Far
layout(location = 1) uniform sampler2D DepthIn;
layout(binding = 0, PIPELINE_DEPTH_COPY_FORMAT) restrict writeonly uniform image2D DepthOut;

// Helper Functions
float LinearizeDepth(float, vec2);
float MinBox4(vec2);

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;
void main()
{
    ivec2 texel = ivec2(gl_GlobalInvocationID.xy);
    vec2 uv = (vec2(texel) + 0.5) / imageSize(DepthOut);

    float depth = 0.0;

    if(int(Settings.x) == HIZ_MODE_COPY)
        depth = LinearizeDepth(textureLod(DepthIn, uv, Settings.y).r, Settings.zw);
    else
        depth = MinBox4(uv);

    imageStore(DepthOut, texel, vec4(depth));
}

float LinearizeDepth(float z, vec2 planes)
{
    z = 2.0 * z - 1.0;
    return  2.0 * planes.x * planes.y / (planes.y + planes.x - z * (planes.y - planes.x));
}

float MinBox4(vec2 uv)
{
    float depth = textureLod(DepthIn, uv, Settings.y).r;
    depth = min(depth, textureLodOffset(DepthIn, uv, Settings.y, ivec2(0, 1)).r);
    depth = min(depth, textureLodOffset(DepthIn, uv, Settings.y, ivec2(1, 0)).r);
    depth = min(depth, textureLodOffset(DepthIn, uv, Settings.y, ivec2(1, 1)).r);

    return depth;
}

