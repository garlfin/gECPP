#include <Resource/Shader/Include/Math.glsl>

#ifndef PIPELINE_DEPTH_COPY_FORMAT
    #define PIPELINE_DEPTH_COPY_FORMAT r32f
#endif

#define HIZ_MODE_COPY 0
#define HIZ_MODE_DOWNSAMPLE 1

// IO
layout(location = 0) uniform vec4 Settings; // Mode, MIP, Near, Far
layout(location = 1) uniform sampler2D DepthIn;
layout(binding = 0, PIPELINE_DEPTH_COPY_FORMAT) restrict writeonly uniform image2D DepthOut;

// Helper Functions
float MinBox4(ivec2);

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;
void main()
{
    ivec2 texel = ivec2(gl_GlobalInvocationID.xy);
    vec2 uv = (vec2(texel) + 0.5) / imageSize(DepthOut);

    float depth = 0.0;

    if(int(Settings.x) == HIZ_MODE_COPY)
        depth = LinearizeDepth(textureLod(DepthIn, uv, Settings.y).r, Settings.zw);
    else
        depth = MinBox4(texel);

    imageStore(DepthOut, texel, vec4(depth));
}

float MinBox4(ivec2 uv)
{
    uv *= 2;

    int sourceMip = int(Settings.y);

    float depth = texelFetch(DepthIn, uv, sourceMip).r;
    depth = min(depth, texelFetch(DepthIn, uv + ivec2(0, 1), sourceMip).r);
    depth = min(depth, texelFetch(DepthIn, uv + ivec2(1, 0), sourceMip).r);
    depth = min(depth, texelFetch(DepthIn, uv + ivec2(1, 1), sourceMip).r);

    ivec2 previousMipSize = textureSize(DepthIn, sourceMip);
    bool changedX = (previousMipSize.x & 1) != 0;
    bool changedY = (previousMipSize.y & 1) != 0;

    if(changedX)
    {
        depth = min(depth, texelFetch(DepthIn, uv + ivec2(2, 0), sourceMip).r);
        depth = min(depth, texelFetch(DepthIn, uv + ivec2(2, 1), sourceMip).r);
    }

    if(changedY)
    {
        depth = min(depth, texelFetch(DepthIn, uv + ivec2(0, 2), sourceMip).r);
        depth = min(depth, texelFetch(DepthIn, uv + ivec2(1, 2), sourceMip).r);
    }

    if(changedX && changedY)
        depth = min(depth, texelFetch(DepthIn, uv + ivec2(2, 2), sourceMip).r);

    return depth;
}

