#extension GL_NV_shader_atomic_float : enable

#include <Resource/Shader/Include/SphericalHarmonics.glsl>

#define SH_GROUP_SIZE 32
#define SH_LOG2_GROUP_SIZE 5
#define SH_MODE_SAMPLE 0
#define SH_MODE_MERGE 1

layout(location = 0) uniform samplerCube Cubemap;
layout(location = 1) uniform uint Mode;

shared ColorHarmonic Harmonics[SH_GROUP_SIZE];

layout(std140, binding = 9) restrict buffer OutputBuffer
{
    ColorHarmonic OutHarmonics[];
};

layout(local_size_x = SH_GROUP_SIZE, local_size_y = 1, local_size_z = 1) in;
void main()
{
    uint localIndex = gl_LocalInvocationIndex;
    uint sampleCount = gl_NumWorkGroups.x * SH_GROUP_SIZE;

    if(Mode == SH_MODE_SAMPLE)
    {
        uint sampleIndex = gl_GlobalInvocationID.x;

        vec3 sampleDir = ToSphere(Hammersley(sampleIndex, sampleCount));
        vec3 sampleColor = texture(Cubemap, sampleDir).rgb;

        ColorHarmonic harmonic = SH_DefaultColorHarmonic;
        SH_Project(harmonic, sampleDir, vec4(sampleColor, 1.0));

        Harmonics[localIndex] = harmonic;

        barrier();

        for(uint batchSize = SH_GROUP_SIZE / 2; batchSize > 0; batchSize /= 2)
        {
            if (localIndex < batchSize)
                Harmonics[localIndex] = SH_Add(Harmonics[localIndex], Harmonics[batchSize + localIndex]);
            barrier();
        }

        if (localIndex == 0)
        {
            SH_NormalizeHarmonic(Harmonics[0], sampleCount);
            OutHarmonics[gl_WorkGroupID.x] = Harmonics[0];
        }
    }
    else
    {
        for(uint batchSize = SH_GROUP_SIZE / 2; batchSize > 0; batchSize /= 2)
        {
            uint mergeIndex = batchSize + localIndex;
            if (localIndex < batchSize && mergeIndex < OutHarmonics.length())
                OutHarmonics[localIndex] = SH_Add(OutHarmonics[localIndex], OutHarmonics[mergeIndex]);

            barrier();
        }
    }
}