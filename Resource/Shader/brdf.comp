#define EPSILON 0.001

#include "Include/PBR.glsl"

#define PI2 (PI * 2.0)
#define SAMPLE_COUNT 1024
#define UP_VECTOR vec3(0.0, 0.0, 1.0)

layout(binding = 0, rg16f) restrict writeonly uniform image2D LUTOut;

// Helper Functions
float VDCInverse(uint bits);
vec2 Hammersley(uint index);

layout(local_size_x = 32, local_size_y = 32, local_size_z = 1) in;
void main()
{
    const ivec2 size = textureSize(LUTOut);
    const float nDotV = max(float(gl_GlobalInvocationID.x) / size.x, EPSILON);
    const float roughness = float(gl_GlobalInvocationID.y) / size.y;

    const vec3 viewDir = vec3(sqrt(1.0 - nDotV * nDotV), 0.0, nDotV);

    vec2 lut = vec2(0.0);
    for(uint i = 0; i < SAMPLE_COUNT; i++)
    {
        vec2 xI = Hammersley(i);
        vec2 h = ImportanceSampleGGX(xI, UP_VECTOR, roughness);
        vec3 l = normalize(2.0 * dot(viewDir, h) * h - viewDir);

        float nDotL = max(l.z, 0.0);
        float nDotH = max(h.z, 0.0);
        float vDotH = max(dot(viewDir, h), 0.0);

        if(nDotL <= 0.0) continue;

        float g = GSchlick(nDotV, nDotL, roughness);
        float visibility = (g * vDotH) / (nDotH / nDotV);
        float fC = pow(1.0 - vDotH, 5.0);

        lut += vec2((1.0 - fC) * visibility, fC * visibility);
    }

    lut /= SAMPLE_COUNT;

    imageStore(LUTOut, ivec2(gl_GlobalInvocationID), vec4(lut.rg, 0.0, 0.0));
}

// Implementation

// How someone came up with that, I don't know.
// http://holger.dammertz.org/stuff/notes_HammersleyOnHemisphere.html
float VDCInverse(uint bits)
{
    bits = (bits << 16u) | (bits >> 16u);
    bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);
    bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);
    bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);
    bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);
    return float(bits) * 2.3283064365386963e-10; // / 0x100000000
}

vec2 Hammersley(uint index)
{
    return vec2(i / SAMPLE_COUNT, VDCInverse(index));
}
